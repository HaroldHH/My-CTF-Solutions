from Crypto.Util.number import inverse, long_to_bytes

# Reference : https://math.stackexchange.com/questions/2730675/decrypt-an-rsa-message-when-its-encrypted-by-same-modulus

e1 = 65537
e2 = 10 ** 9 + 7
# Find s1 and s2 with egcd. Use https://www.dcode.fr/extended-gcd
s1 = -256465815
s2 = 16808

n = 65187076454333342926241302602095875830502176008209471473602867310115801692549990272206959368572619686228333489588252859308181692664733576004899501154332>
c1 = 4774715644202311524170834257638951232571396978438901202280156069591213703319995869125845033778908535370039919119058655864300442133107117615307796032767>
c2 = 4588027273799252545257351195562327471115379306928523894160917253310033894029079227894588687306877959900423182403854065722636216400910297579660099891495>

ss1 = inverse(c1, n)

# Decrypt the ciphertext
d1 = pow(ss1, -(s1), n)
d2 = pow(c2, s2, n)
result = (d1 * d2)
result = result % n

print(long_to_bytes(result).decode())
